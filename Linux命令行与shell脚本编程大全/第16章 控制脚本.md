# 第16章 控制脚本

```
脚本控制方法：向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式。
```

---

## 处理信号
	Linux利用信号与运行在系统中的进程进行通信。第4章介绍了不同的Linux信号以及Linux如何用这些信号来停止、启动、终止进程。可以通过对脚本进行编程，使其在收到特定信号时执行某些命令，从而控制shell脚本的操作。

- 重温常见 Linux 信号

  ```
  信 号 			值 					描 述
  1 				SIGHUP 				挂起进程
  2 				SIGINT 				终止进程
  3 				SIGQUIT 			停止进程
  9 				SIGKILL 			无条件终止进程
  15 				SIGTERM 			尽可能终止进程
  17 				SIGSTOP 			无条件停止进程，但不是终止进程
  18 				SIGTSTP 			停止或暂停进程，但不终止进程
  19 				SIGCONT 			继续运行停止的进程
  
  	默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。
  	如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。
  	通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。
  ```

  - 生成信号

    ```
    bash shell允许用键盘上的组合键生成两种基本的Linux信号。这个特性在需要停止或暂停失控程序时非常方便。
    ```

    - 中断进程

      ```shell
      Ctrl+C组合键会生成SIGINT信号，并将其发送给当前在shell中运行的所有进程。
      $ sleep 100
    ^C
      $
      ```
    ```
    
    - 暂停进程
    
    	```shell
    你可以在进程运行期间暂停进程，而无需终止它。通常它可以在不终止进程的情况下使你能够深入脚本内部一窥究竟。Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程。停止（stopping）进程跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。
    	
    	$ sleep 100
    	^Z
    	[1]+ Stopped sleep 100
    	$
    	
    	方括号中的数字是shell分配的作业号。shell将shell中运行的每个进程称为作业，分配唯一的作业号。如果你的shell会话中有一个已停止的作业，在退出shell时，bash会提醒你。
    	
    	$ sleep 100
    	^Z
    	[1]+ Stopped sleep 100
    	$ exit
    	exit
    	There are stopped jobs.
    	$
    	
    	可以用 ps 命令来查看已停止的作业
    	
    	$ sleep 100
    	^Z
    	[1]+ Stopped sleep 100
    	$
    	$ ps -l
    	F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD
    	0 S 501 2431 2430 0 80 0 - 27118 wait pts/0 00:00:00 bash
    	0 T 501 2456 2431 0 80 0 - 25227 signal pts/0 00:00:00 sleep
    	0 R 501 2458 2431 0 80 0 - 27034 - pts/0 00:00:00 ps
    	$
    	
    	在S列中（进程状态），ps命令将已停止作业的状态为显示为T。这说明命令要么被跟踪，要么被停止了。
    	如果在有已停止作业存在的情况下，你仍旧想退出shell，只要再输入一遍exit命令就行了。shell会退出，终止已停止作业。或者，既然你已经知道了已停止作业的PID，就可以用kill命令来发送一个SIGKILL信号来终止它。
    	
    	$ kill -9 2456
    	$
    	[1]+ Killed sleep 100
    	$
  ```
  
- 捕获信号
  
    ```shell
    也可以不忽略信号，在信号出现时捕获它们并执行其他命令。trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理。
    
    trap commands signals
    可以用数值或Linux信号名来指定信号。
    $ cat test1.sh
    #!/bin/bash
    # Testing signal trapping
    #
    trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT
    #
    echo This is a test script
    #
    count=1
    while [ $count -le 10 ]
    do
    echo "Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
    done
    #
    echo "This is the end of the test script"
    #
    
    在每次检测到SIGINT信号时显示一行简单的文本消息。捕获这些信号会阻止用户用bash shell组合键Ctrl+C来停止程序。
    
    $ ./test1.sh
    This is a test script
    Loop #1
    Loop #2
    Loop #3
    Loop #4
    Loop #5
    ^C Sorry! I have trapped Ctrl-C
    Loop #6
    Loop #7
    Loop #8
    ^C Sorry! I have trapped Ctrl-C
    Loop #9
    Loop #10
    This is the end of the test script
    $
    
    每次使用Ctrl+C组合键，脚本都会执行trap命令中指定的echo语句，而不是处理该信号并允许shell停止该脚本。
  ```
  
  - 捕获脚本退出
    
  ```shell
    除了在shell脚本中捕获信号，你也可以在shell脚本退出时进行捕获。这是在shell完成任务时执行命令的一种简便方法。要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就行。
    
    $ cat test2.sh
    #!/bin/bash
    # Trapping the script exit
    #
    trap "echo Goodbye..." EXIT
    #
    count=1
    while [ $count -le 5 ]
  do
    echo "Loop #$count"
    sleep 1
  count=$[ $count + 1 ]
    done
    #
    $
    $ ./test2.sh
    Loop #1
    Loop #2
    Loop #3
    Loop #4
    Loop #5
    Goodbye...
    $
    
    当脚本运行到正常的退出位置时，捕获就被触发了，shell会执行在trap命令行指定的命令。如果提前退出脚本，同样能够捕获到EXIT。
    
    $ ./test2.sh
    Loop #1
    Loop #2
    Loop #3
    ^CGoodbye...
    $
    
    因为SIGINT信号并没有出现在trap命令的捕获列表中，当按下Ctrl+C组合键发送SIGINT信
    号时，脚本就退出了。但在脚本退出前捕获到了EXIT，于是shell执行了trap命令。
  ```
  
  - 修改或移除捕获
    
    ```shell
    要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。
    
    $ cat test3.sh
    #!/bin/bash
    # Modifying a set trap
    #
    trap "echo ' Sorry... Ctrl-C is trapped.'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
    echo "Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
    done
    #
    trap "echo ' I modified the trap!'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
    echo "Second Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
    done
    #
    $
    
    修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。
    
    $ ./test3.sh
    Loop #1
    Loop #2
    Loop #3
    ^C Sorry... Ctrl-C is trapped.
    Loop #4
    Loop #5
    Second Loop #1
    Second Loop #2
    ^C I modified the trap!
    Second Loop #3
    Second Loop #4
    Second Loop #5
    $
    
    也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。
    
    $ cat test3b.sh
    #!/bin/bash
    # Removing a set trap
    #
    trap "echo ' Sorry... Ctrl-C is trapped.'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
    echo "Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
    done
    #
    # Remove the trap
    trap -- SIGINT
    echo "I just removed the trap"
    #
    count=1
    while [ $count -le 5 ]
    do
    echo "Second Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
    done
    #
    $ ./test3b.sh
    Loop #1
    Loop #2
    Loop #3
    Loop #4
    Loop #5
    I just removed the trap
    Second Loop #1
    Second Loop #2
    Second Loop #3
    ^C
    $
    
    移除信号捕获后，脚本按照默认行为来处理SIGINT信号，也就是终止脚本运行。但如果信号是在捕获被移除前接收到的，那么脚本会按照原先trap命令中的设置进行处理。
    
    $ ./test3b.sh
    Loop #1
    Loop #2
    Loop #3
    ^C Sorry... Ctrl-C is trapped.
    Loop #4
    Loop #5
    I just removed the trap
    Second Loop #1
    Second Loop #2
    ^C
    $
    
    在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，脚本会照旧执行trap中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。
    ```

---

## 以后台模式运行脚本

- 临时重定向

  ```shell
  $ cat test8
  #!/bin/bash
  # testing STDERR messages
  echo "This is an error" >&2
  echo "This is normal output"
  $
  $ ./test8
  This is an error
  This is normal output
  $
  $ ./test8 2> test9
  This is normal output
  $ cat test9
  This is an error
  $
  ```

  这个方法非常适合在脚本中生成错误消息，可以轻松地通过STDERR文件描述符重定向错误消息。

- 永久重定向
  用`exec`命令告诉shell在脚本执行期间重定向某个特定文件描述符

  ```shell
  $ cat test10
  #!/bin/bash
  # redirecting all output to a file
  exec 1>testout
  echo "This is a test of redirecting all output"
  echo "from a script to another file."
  echo "without having to redirect every individual line"
  $ ./test10
  $ cat testout
  This is a test of redirecting all output
  from a script to another file.
  without having to redirect every individual line
  $
  ```

    一旦重定向了STDOUT或STDERR，就很难再将它们重定向回原来的位置。

---

## 在脚本中重定向输入

```shell
$ cat test12
#!/bin/bash
# redirecting file input
exec 0< testfile
count=1
while read line
do
	echo "Line #$count: $line"
	count=$[ $count + 1 ]
done
$ ./test12
Line #1: This is the first line.
Line #2: This is the second line.
Line #3: This is the third line.
$

将STDIN重定向到文件后，当`read`命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘。这是在脚本中从待处理的文件中读取数据的绝妙办法。
```

---

## 创建自己的重定向

- 创建输出文件描述符
  在脚本中使用其他文件描述符的简单例子。一直有效直到重新分配。

  ```shell
  $ cat test13
  #!/bin/bash
  # using an alternative file descriptor
  exec 3>test13out
  echo "This should display on the monitor"
  echo "and this should be stored in the file" >&3
  echo "Then this should be back on the monitor"
  $ ./test13
  This should display on the monitor
  Then this should be back on the monitor
  $ cat test13out
  and this should be stored in the file
  $
  ```

  也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。

  ```shell
  exec 3>>test13out
  ```

- 重定向文件描述符
  恢复重定向之前的文件描述符例子。

  ```shell
  $ cat test14
  #!/bin/bash
  # storing STDOUT, then coming back to it
  exec 3>&1
  exec 1>test14out
  echo "This should store in the output file"
  echo "along with this line."
  exec 1>&3
  echo "Now things should be back to normal"
  $
  $ ./test14
  Now things should be back to normal
  $ cat test14out
  This should store in the output file
  along with this line.
  $
  ```

- 创建输入文件描述符 319页

- 创建读写文件描述符 320页

- 关闭文件描述符
  如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们。手动关闭可以使用`exec 3>&-`将它重定向到特殊符号&-。

---

## 列出打开的文件描述符

要想以普通用户运行`lsof`命令需要用全路径;`-p`指定 `$$`特殊环境变量——当前PID;`-d`允许指定要显示的文件描述符编号;`-a`对其他两个选项运行的结果执行布尔AND运算;默认产生7列输出


```shell
$ /usr/sbin/lsof -a -p $$ -d 0,1,2
COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME
bash 3344 rich 0u CHR 136,0 2 /dev/pts/0
bash 3344 rich 1u CHR 136,0 2 /dev/pts/0
bash 3344 rich 2u CHR 136,0 2 /dev/pts/0
$

COMMAND 正在运行的命令名的前9个字符
PID 进程的PID
USER 进程属主的登录名
FD 文件描述符号以及访问类型（r代表读，w代表写，u代表读写）
TYPE 文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）
DEVICE 设备的设备号（主设备号和从设备号）
SIZE 如果有的话，表示文件的大小
NODE 本地文件的节点号
NAME 文件名
```

---

## 阻止命令输出

```shell
在将脚本作为后台程序运行时常常不想显示脚本的输出。可以将STDERR重定向到一个叫作null文件的特殊文件，输出到里面的数据不会保存，全部丢弃。Linux上其标准位置是/dev/null。

$ ls -al > /dev/null
$ cat /dev/null
$
    
避免出现错误消息也无需保存它们的常用方法
   	
$ ls -al badfile test16 2> /dev/null
-rwxr--r-- 1 rich rich 135 Oct 29 19:57 test16*
$

也可以在输入重定向中将/dev/null作为输入文件，程序员常用来快速清除现有文件的数据，而不用先删除文件再重新创建。

$ cat testfile
This is the first line.
This is the second line.
This is the third line.
$ cat /dev/null > testfile
$ cat testfile
$

这是清除日志文件的常用方法，因为日志文件必须时刻准备等待应用程序操作。
```

---

## 创建临时文件

	Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。任何用户账户都有权限读写。

- 创建临时文件

  ```shell
  $ mktemp testing.XXXXXX
  $ ls -al testing*
  -rw------- 1 rich rich 0 Oct 17 21:30 testing.UfIi13
  $
  
  mktemp用6个字符码替换6个x，从而保证文件名在目录中是唯一的;
  mktemp命令默认返回创建的文件名;
  ```

  可能要将文件名保存到变量中，这样就能在后面的脚本中引用了。

  ```shell
  tempfile=$(mktemp test19.XXXXXX)
  exec 3>$tempfile
  ```

- 在/tmp目录创建临时文件
  `-t`选项强制在系统的临时目录/tmp/来创建该文件，返回全路径。

  ```shell
  $ mktemp -t test.XXXXXX
  /tmp/test.xG3374
  $ ls -al /tmp/test*
  -rw------- 1 rich rich 0 2014-10-29 18:41 /tmp/test.xG3374
  $
  
  可以在任何命令中使用该值来引用临时文件
  tempfile=$(mktemp -t tmp.XXXXXX)
  echo "This is a test file." > $tempfile
  echo "This is the second line of the test." >> $tempfile
  ```

- 创建临时目录
  `-d`选项创建临时目录

  ```shell
  tempdir=$(mktemp -d dir.XXXXXX)
  cd $tempdir
  ```

---

## 记录消息

有时候需要将输出同时发送到显示器和日志文件。可以用T型接头命令`tee`,它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是`tee filename`命令行所指定的文件名。

```shell
$ date | tee testfile
Sun Oct 19 18:56:21 EDT 2014
$ cat testfile
Sun Oct 19 18:56:21 EDT 2014
$
```

```shell
$ date | tee -a testfile 数据追加到文件。现在就可以在为用户显示输出的同时再永久保存一份输出内容了。
```

---

## 实例

脚本读入文件和输出文件的实例，从.csv格式的数据文件，输出SQL INSERT来将数据插入数据库。

```shell
    $cat test23
    #!/bin/bash
    # read file and create INSERT statements for MySQL
    outfile='members.sql'
    IFS=','
    while read lname fname address city state zip
    do
    	cat >> $outfile << EOF
    	INSERT INTO members (lname,fname,address,city,state,zip) VALUES
    ('$lname', '$fname', '$address', '$city', '$state', '$zip');
    EOF
    done < ${1}
    $
```

现在可以将members.sql文件导入MySQL数据表中了

```sql
    $ cat members.sql
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('Blum',
    'Richard', '123 Main St.', 'Chicago', 'IL', '60601');
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('Blum',
    'Barbara', '123 Main St.', 'Chicago', 'IL', '60601');
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('Bresnahan',
    'Christine', '456 Oak Ave.', 'Columbus', 'OH', '43201');
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('Bresnahan',
    'Timothy', '456 Oak Ave.', 'Columbus', 'OH', '43201');
    $
```

